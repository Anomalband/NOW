generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String           @id @default(cuid())
  displayName     String
  age             Int
  city            String           @default("Istanbul")
  karma           Int              @default(0)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  dailyProfiles   DailyProfile[]
  questSelections QuestSelection[]
  sentMessages    Message[]        @relation("SenderMessages")
  matchesAsA      Match[]          @relation("MatchesAsA")
  matchesAsB      Match[]          @relation("MatchesAsB")
  karmaEvents     KarmaEvent[]
}

model DailyProfile {
  id        String   @id @default(cuid())
  userId    String
  dayKey    String
  district  String
  photoUrl  String
  mood      String?
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, dayKey])
  @@index([district])
  @@index([expiresAt])
}

model Quest {
  id        String           @id @default(cuid())
  title     String
  district  String
  active    Boolean          @default(true)
  createdAt DateTime         @default(now())
  selections QuestSelection[]
  matches   Match[]

  @@unique([title, district])
  @@index([district, active])
}

model QuestSelection {
  id        String   @id @default(cuid())
  userId    String
  questId   String
  dayKey    String
  selectedAt DateTime @default(now())
  expiresAt DateTime
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  quest     Quest    @relation(fields: [questId], references: [id], onDelete: Cascade)

  @@unique([userId, dayKey])
  @@index([questId, dayKey])
  @@index([expiresAt])
}

enum MatchStatus {
  PENDING
  ACCEPTED
  COMPLETED
  CANCELLED
}

model Match {
  id               String      @id @default(cuid())
  userAId          String
  userBId          String
  questId          String
  status           MatchStatus @default(PENDING)
  createdAt        DateTime    @default(now())
  expiresAt        DateTime
  proofPhotoA      String?
  proofPhotoB      String?
  proofSubmittedAAt DateTime?
  proofSubmittedBAt DateTime?
  confirmedByAAt   DateTime?
  confirmedByBAt   DateTime?
  completedAt      DateTime?
  userA            User        @relation("MatchesAsA", fields: [userAId], references: [id], onDelete: Cascade)
  userB            User        @relation("MatchesAsB", fields: [userBId], references: [id], onDelete: Cascade)
  quest            Quest       @relation(fields: [questId], references: [id], onDelete: Cascade)
  messages         Message[]
  karmaEvents      KarmaEvent[]

  @@index([questId, status])
  @@index([expiresAt])
  @@index([userAId, status])
  @@index([userBId, status])
}

model Message {
  id        String   @id @default(cuid())
  matchId   String
  senderId  String
  content   String
  createdAt DateTime @default(now())
  expiresAt DateTime
  match     Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  sender    User     @relation("SenderMessages", fields: [senderId], references: [id], onDelete: Cascade)

  @@index([matchId, createdAt])
  @@index([expiresAt])
}

model KarmaEvent {
  id        String   @id @default(cuid())
  userId    String
  matchId   String?
  delta     Int
  reason    String
  metadata  Json?
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  match     Match?   @relation(fields: [matchId], references: [id], onDelete: SetNull)

  @@index([userId, createdAt])
  @@index([matchId])
}
